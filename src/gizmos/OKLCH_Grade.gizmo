Gizmo {
 help "<b>OKLCH Grade</b>\nPerceptually uniform color grading with intuitive Lightness, Chroma, and Hue controls."
 onCreate "import oklch_grade_callbacks as _okcb\n_okcb.initialize_this_node()"
 tile_color 0x3e5f9fff
 addUserKnob {20 OKLCHGrade l "OKLCH Grade"}
 addUserKnob {26 status_text l "" +STARTLINE T "<font color='#777777'><small><b>Status:</b> Note: no linear-sRGB alias found. Falling back to scene_linear.</small></font>"}
 addUserKnob {20 colorspace_group l Colorspace n 1}
 addUserKnob {41 input_colorspace l "Input Colorspace" T OCIOColorSpace_IN.in_colorspace}
 addUserKnob {41 output_colorspace l "Output Colorspace" T OCIOColorSpace_OUT.out_colorspace}
 addUserKnob {20 colorspace_group_end n -1}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {20 grade_group l "Lightness & Chroma" n 1}
 addUserKnob {41 l_gain l "L Gain" R 0 3 T "BlinkScript_OKLCHGrade.l_gain"}
 addUserKnob {41 l_offset l "L Offset" R -1 1 T "BlinkScript_OKLCHGrade.l_offset"}
 addUserKnob {41 l_contrast l "L Contrast" R 0 3 T "BlinkScript_OKLCHGrade.l_contrast"}
 addUserKnob {41 l_pivot l "L Pivot" R 0 1 T "BlinkScript_OKLCHGrade.l_pivot"}
 addUserKnob {41 c_gain l "C Gain" R 0 2 T "BlinkScript_OKLCHGrade.c_gain"}
 addUserKnob {41 c_offset l "C Offset" R -0.5 0.5 T "BlinkScript_OKLCHGrade.c_offset"}
 addUserKnob {20 grade_group_end n -1}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {20 hue_group l Hue n 1}
 addUserKnob {41 hue_shift_deg l "Hue Shift (deg)" R -360 360 T "BlinkScript_OKLCHGrade.hue_shift_deg"}
 addUserKnob {41 hue_chroma_threshold l "Hue Chroma Threshold" R 0 0.2 T "BlinkScript_OKLCHGrade.hue_chroma_threshold"}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 hue_bands_label l "" +STARTLINE T "<b>Hue Band Selectors</b> <small>(85° Cosine Window)</small>"}
 addUserKnob {26 dot_red l "<font color='#FF6666'>●</font>" +STARTLINE T ""}
 addUserKnob {41 hue_shift_red l "Hue Shift Red" R -180 180 -STARTLINE T "BlinkScript_OKLCHGrade.hue_shift_red"}
 addUserKnob {26 dot_yellow l "<font color='#EEEE66'>●</font>" +STARTLINE T ""}
 addUserKnob {41 hue_shift_yellow l "Hue Shift Yellow" R -180 180 -STARTLINE T "BlinkScript_OKLCHGrade.hue_shift_yellow"}
 addUserKnob {26 dot_green l "<font color='#66FF66'>●</font>" +STARTLINE T ""}
 addUserKnob {41 hue_shift_green l "Hue Shift Green" R -180 180 -STARTLINE T "BlinkScript_OKLCHGrade.hue_shift_green"}
 addUserKnob {26 dot_cyan l "<font color='#66FFFF'>●</font>" +STARTLINE T ""}
 addUserKnob {41 hue_shift_cyan l "Hue Shift Cyan" R -180 180 -STARTLINE T "BlinkScript_OKLCHGrade.hue_shift_cyan"}
 addUserKnob {26 dot_blue l "<font color='#6666FF'>●</font>" +STARTLINE T ""}
 addUserKnob {41 hue_shift_blue l "Hue Shift Blue" R -180 180 -STARTLINE T "BlinkScript_OKLCHGrade.hue_shift_blue"}
 addUserKnob {26 dot_magenta l "<font color='#FF66FF'>●</font>" +STARTLINE T ""}
 addUserKnob {41 hue_shift_magenta l "Hue Shift Magenta" R -180 180 -STARTLINE T "BlinkScript_OKLCHGrade.hue_shift_magenta"}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {41 hue_target_deg l "Hue Target (deg)" R 0 360 T "BlinkScript_OKLCHGrade.hue_target_deg"}
 addUserKnob {41 hue_target_shift l "Hue Target Shift" R -180 180 T "BlinkScript_OKLCHGrade.hue_target_shift"}
 addUserKnob {41 hue_target_falloff_deg l "Hue Target Falloff" R 1 180 T "BlinkScript_OKLCHGrade.hue_target_falloff_deg"}
 addUserKnob {20 hue_group_end n -1}
 addUserKnob {20 hue_curves_tab l "Hue Curves"}
 addUserKnob {41 hue_curves_enable l "Enable Hue Curves" T "BlinkScript_OKLCHGrade.hue_curves_enable"}
 addUserKnob {26 hue_curves_help l "" +STARTLINE T "<small>Draw curves to adjust Hue/Chroma/Lightness per input hue. X axis = OKLCH hue (0° left → 360° right). Y = 0.5 is neutral. Note: curves do not wrap at 0°/360° — extend adjustments to both edges for hues near red.</small>"}
 addUserKnob {26 curve_mapping_label l "" +STARTLINE T "<b>Curve Mapping</b> <small>R = Hue Shift, G = Chroma Gain, B = Lightness Gain</small>"}
 addUserKnob {41 hue_curves_lut l "Hue Curves" T ColorLookup_HueCurves.lut}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {41 mix l Mix R 0 1 T BlinkScript_OKLCHGrade.mix}
 addUserKnob {41 clamp_output l "Clamp Output" T "BlinkScript_OKLCHGrade.clamp_output"}
 addUserKnob {20 advanced_tab l Advanced}
 addUserKnob {41 bypass l Bypass T BlinkScript_OKLCHGrade.bypass}
 addUserKnob {41 debug_mode l "Debug Mode" T "BlinkScript_OKLCHGrade.debug_mode"}
 addUserKnob {26 debug_modes_help l "" +STARTLINE T "<small>Debug modes: 0=Off, 1=L, 2=C, 3=H, 4=Chroma Weight, 5=Hue Curves LUT</small>"}
 addUserKnob {1 working_linear_srgb_space l "Working Linear sRGB" +INVISIBLE T scene_linear}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {26 info_label l "" +STARTLINE T "<b>Reference Anchors</b>"}
 addUserKnob {26 hue_info l "" +STARTLINE T "R: 0° | Y: 85° | G: 145° | C: 195° | B: 265° | M: 325°"}

}
 Expression {
  inputs 0
  temp_name0 norm_x
  temp_expr0 "(x + 0.5) / width"
  expr0 norm_x
  expr1 norm_x
  expr2 norm_x
  format "360 1 0 0 360 1 1 HueLUT_360x1"
  name Expression_HueRamp
  xpos -355
  ypos -258
 }
 ColorLookup {
  inputs 1
  lut {master {}
       red {curve 0.5}
       green {curve 0.5}
       blue {curve 0.5}
       alpha {}}
  name ColorLookup_HueCurves
  xpos -355
  ypos -208
 }
set Nae4b1382 [stack 0]
 Input {
  inputs 0
  name Input1
  xpos -100
  ypos -260
 }
 OCIOColorSpace {
  in_colorspace scene_linear
  out_colorspace scene_linear
  name OCIOColorSpace_IN
  xpos -100
  ypos -210
 }
push $Nae4b1382
 BlinkScript {
  inputs 2
  recompileCount 2
  kernelSource "kernel OKLCHGrade : ImageComputationKernel<ePixelWise> \{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eRead, eAccessRandom, eEdgeClamped> hueLUT;\n  Image<eWrite> dst;\n\nparam:\n  // --- Lightness ---\n  float l_gain;\n  float l_offset;\n  float l_contrast;\n  float l_pivot;\n\n  // --- Chroma ---\n  float c_gain;\n  float c_offset;\n\n  // --- Global Hue ---\n  // Shifts ALL hues by a constant offset in degrees.\n  // The effect fades to zero for near-achromatic pixels (Chroma <\n  // hue_chroma_threshold), preventing muddy grey casts when rotating hue\n  // globally.\n  float hue_shift_deg;\n  float hue_chroma_threshold; // Chroma below which the global+band shifts fade\n                              // out (0..0.2)\n\n  // --- Hue Band Selectors ---\n  // Each shifts only the pixels whose original hue falls within that colour\n  // band. Influence falls off smoothly away from each band centre using a\n  // cosine window (half-angle = 60 deg), so adjacent bands overlap and blend\n  // naturally like a colour wheel divided into six 60-degree sectors.\n  //\n  //  Band centres (OKLCH hue wheel, perceptually placed):\n  //    Red     ~  0 / 360 deg\n  //    Yellow  ~ 85 deg\n  //    Green   ~ 145 deg\n  //    Cyan    ~ 195 deg\n  //    Blue    ~ 265 deg\n  //    Magenta ~ 325 deg\n  float hue_shift_red;\n  float hue_shift_yellow;\n  float hue_shift_green;\n  float hue_shift_cyan;\n  float hue_shift_blue;\n  float hue_shift_magenta;\n\n  // --- Target Hue Correction ---\n  float hue_target_deg;\n  float hue_target_shift;\n  float hue_target_falloff_deg;\n\n  // --- Utilities ---\n  float mix;\n  bool clamp_output;\n  bool bypass;\n  int debug_mode;\n\n  // --- Hue Curves ---\n  bool hue_curves_enable;\n  int hue_lut_width;\n  bool hue_lut_connected;\n\n  void define() \{\n    defineParam(l_gain, \"L Gain\", 1.0f);\n    defineParam(l_offset, \"L Offset\", 0.0f);\n    defineParam(l_contrast, \"L Contrast\", 1.0f);\n    defineParam(l_pivot, \"L Pivot\", 0.18f);\n    defineParam(c_gain, \"C Gain\", 1.0f);\n    defineParam(c_offset, \"C Offset\", 0.0f);\n\n    defineParam(hue_shift_deg, \"Hue Shift (deg)\", 0.0f);\n    defineParam(hue_chroma_threshold, \"Hue Chroma Threshold\", 0.05f);\n\n    defineParam(hue_shift_red, \"Hue Shift Red\", 0.0f);\n    defineParam(hue_shift_yellow, \"Hue Shift Yellow\", 0.0f);\n    defineParam(hue_shift_green, \"Hue Shift Green\", 0.0f);\n    defineParam(hue_shift_cyan, \"Hue Shift Cyan\", 0.0f);\n    defineParam(hue_shift_blue, \"Hue Shift Blue\", 0.0f);\n    defineParam(hue_shift_magenta, \"Hue Shift Magenta\", 0.0f);\n\n    defineParam(hue_target_deg, \"Hue Target (deg)\", 0.0f);\n    defineParam(hue_target_shift, \"Hue Target Shift\", 0.0f);\n    defineParam(hue_target_falloff_deg, \"Hue Target Falloff\", 25.0f);\n\n    defineParam(mix, \"Mix\", 1.0f);\n    defineParam(clamp_output, \"Clamp Output\", false);\n    defineParam(bypass, \"Bypass\", false);\n    defineParam(debug_mode, \"Debug Mode\", 0);\n\n    defineParam(hue_curves_enable, \"Hue Curves Enable\", false);\n    defineParam(hue_lut_width, \"Hue LUT Width\", 360);\n    defineParam(hue_lut_connected, \"Hue LUT Connected\", false);\n  \}\n\n  // ---------------------------------------------------------------------------\n  // Helpers\n  // ---------------------------------------------------------------------------\n\n  float signed_cbrt(float x) \{\n    if (x == 0.0f)\n      return 0.0f;\n    return (x > 0.0f) ? pow(x, 1.0f / 3.0f) : -pow(-x, 1.0f / 3.0f);\n  \}\n\n  float clamp01(float x) \{ return clamp(x, 0.0f, 1.0f); \}\n\n  // Smoothstep is not a Blink built-in (it is GLSL-only).\n  // This replicates the standard cubic Hermite polynomial: 3t^2 - 2t^3\n  float smooth_ramp(float edge0, float edge1, float x) \{\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n    return t * t * (3.0f - 2.0f * t);\n  \}\n\n  float wrap_hue_deg(float h) \{\n    float wrapped = h - 360.0f * floor(h / 360.0f);\n    return (wrapped < 0.0f) ? wrapped + 360.0f : wrapped;\n  \}\n\n  // Shortest angular distance from angle a to angle b, in degrees.\n  // Returns a value in \[-180, 180\].\n  float hue_delta(float a, float b) \{\n    float d = wrap_hue_deg(b) - wrap_hue_deg(a);\n    if (d > 180.0f)\n      d -= 360.0f;\n    if (d < -180.0f)\n      d += 360.0f;\n    return d;\n  \}\n\n  // Cosine-window hue band weight.\n  // Returns 1 at centre_deg, 0 at +/-half_width_deg, smooth in between.\n  // Clamped to \[0,1\] so it never goes negative at the edges.\n  float hue_band_weight(float current_hue, float centre_deg,\n                        float half_width_deg) \{\n    float delta = hue_delta(current_hue, centre_deg);\n    float norm = delta / half_width_deg; // -1 to 1 at the edges\n    if (norm < -1.0f || norm > 1.0f)\n      return 0.0f;\n    // cos(pi * norm): 1 at centre, 0 at edges, smooth cosine falloff\n    float pi = 3.1415926536f;\n    return 0.5f * (1.0f + cos(pi * norm));\n  \}\n\n  float3 sample_hue_lut(float hue_deg) \{\n    float w = max(float(hue_lut_width), 2.0f);\n    float norm = wrap_hue_deg(hue_deg) / 360.0f;\n    float lut_x = norm * (w - 1.0f);\n    float4 lut_val = bilinear(hueLUT, lut_x + 0.5f, 0.5f);\n    return float3(lut_val.x, lut_val.y, lut_val.z);\n  \}\n\n  // ---------------------------------------------------------------------------\n  // Colour space conversion matrices\n  // ---------------------------------------------------------------------------\n\n  float3 linear_srgb_to_xyz(float3 rgb) \{\n    // CSS Color 4: lin_sRGB_to_XYZ (D65)\n    float x = 0.4123907992659595f * rgb.x + 0.3575843393838780f * rgb.y +\n              0.1804807884018343f * rgb.z;\n    float y = 0.2126390058715104f * rgb.x + 0.7151686787677559f * rgb.y +\n              0.0721923153607337f * rgb.z;\n    float z = 0.0193308187155918f * rgb.x + 0.1191947797946260f * rgb.y +\n              0.9505321522496606f * rgb.z;\n    return float3(x, y, z);\n  \}\n\n  float3 xyz_to_linear_srgb(float3 xyz) \{\n    // CSS Color 4: XYZ_to_lin_sRGB\n    float r = 3.2409699419045213f * xyz.x + -1.5373831775700935f * xyz.y +\n              -0.4986107602930033f * xyz.z;\n    float g = -0.9692436362808798f * xyz.x + 1.8759675015077206f * xyz.y +\n              0.0415550574071756f * xyz.z;\n    float b = 0.0556300796969936f * xyz.x + -0.2039769588889766f * xyz.y +\n              1.0569715142428786f * xyz.z;\n    return float3(r, g, b);\n  \}\n\n  float3 xyz_to_oklab(float3 xyz) \{\n    // CSS Color 4: XYZ_to_OKLab\n    float l = 0.8190224379967030f * xyz.x + 0.3619062600528904f * xyz.y +\n              -0.1288737815209879f * xyz.z;\n    float m = 0.0329836539323885f * xyz.x + 0.9292868615863434f * xyz.y +\n              0.0361446663506424f * xyz.z;\n    float s = 0.0481771893596242f * xyz.x + 0.2642395317527308f * xyz.y +\n              0.6335478284694309f * xyz.z;\n\n    float l_ = signed_cbrt(l);\n    float m_ = signed_cbrt(m);\n    float s_ = signed_cbrt(s);\n\n    float L = 0.2104542683093140f * l_ + 0.7936177747023054f * m_ +\n              -0.0040720430116193f * s_;\n    float a = 1.9779985324311684f * l_ + -2.4285922420485799f * m_ +\n              0.4505937096174110f * s_;\n    float b = 0.0259040424655478f * l_ + 0.7827717124575296f * m_ +\n              -0.8086757549230774f * s_;\n\n    return float3(L, a, b);\n  \}\n\n  float3 oklab_to_xyz(float3 lab) \{\n    // CSS Color 4: OKLab_to_XYZ\n    float l_ = 1.0f * lab.x + 0.3963377773761749f * lab.y +\n               0.2158037573099136f * lab.z;\n    float m_ = 1.0f * lab.x + -0.1055613458156586f * lab.y +\n               -0.0638541728258133f * lab.z;\n    float s_ = 1.0f * lab.x + -0.0894841775298119f * lab.y +\n               -1.2914855480194092f * lab.z;\n\n    float l = l_ * l_ * l_;\n    float m = m_ * m_ * m_;\n    float s = s_ * s_ * s_;\n\n    float x = 1.2268798758459243f * l + -0.5578149944602171f * m +\n              0.2813910456659647f * s;\n    float y = -0.0405757452148008f * l + 1.1122868032803170f * m +\n              -0.0717110580655164f * s;\n    float z = -0.0763729366746601f * l + -0.4214933324022432f * m +\n              1.5869240198367816f * s;\n\n    return float3(x, y, z);\n  \}\n\n  float3 oklab_to_oklch(float3 lab) \{\n    float c = sqrt((lab.y * lab.y) + (lab.z * lab.z));\n    float h = atan2(lab.z, lab.y) * 57.2957795131f;\n\n    if (h < 0.0f) \{\n      h += 360.0f;\n    \}\n\n    if (c <= 0.000004f) \{\n      h = 0.0f;\n    \}\n\n    return float3(lab.x, c, h);\n  \}\n\n  float3 oklch_to_oklab(float3 lch) \{\n    float rad = lch.z * (3.1415926536f / 180.0f);\n    float a = lch.y * cos(rad);\n    float b = lch.y * sin(rad);\n    return float3(lch.x, a, b);\n  \}\n\n  // ---------------------------------------------------------------------------\n  // Process\n  // ---------------------------------------------------------------------------\n\n  void process() \{\n    float4 src_pixel = src();\n    float3 in_rgb = float3(max(0.0f, src_pixel.x), max(0.0f, src_pixel.y),\n                           max(0.0f, src_pixel.z));\n\n    if (bypass) \{\n      dst() = src_pixel;\n      return;\n    \}\n\n    float3 current_xyz = linear_srgb_to_xyz(in_rgb);\n    float3 current_lab = xyz_to_oklab(current_xyz);\n    float3 current_lch = oklab_to_oklch(current_lab);\n\n    // --- Grade L and C ---\n    float graded_L = (current_lch.x * l_gain) + l_offset;\n    float safe_pivot = max(l_pivot, 0.0f);\n    float safe_contrast = max(l_contrast, 0.0f);\n    graded_L = ((graded_L - safe_pivot) * safe_contrast) + safe_pivot;\n    float graded_C = (current_lch.y * c_gain) + c_offset;\n\n    if (graded_L < 0.0f)\n      graded_L = 0.0f;\n    if (graded_C < 0.0f)\n      graded_C = 0.0f;\n\n    // --- Hue Curves: per-hue L/C multipliers ---\n    if (hue_curves_enable && hue_lut_connected && hue_lut_width > 1) \{\n      float3 lut = sample_hue_lut(current_lch.z);\n      float l_curve_mult = lut.z * 2.0f; // Blue channel\n      float c_curve_mult = lut.y * 2.0f; // Green channel\n      graded_L = max(graded_L * l_curve_mult, 0.0f);\n      graded_C = max(graded_C * c_curve_mult, 0.0f);\n    \}\n\n    // --- Grade H ---\n    // Feature 1: Chroma-based weight.\n    // Below hue_chroma_threshold, all hue shifts fade to zero — achromatic\n    // pixels (neutrals, near-blacks, near-whites) are left untouched.\n    // smooth_ramp() is our own cubic Hermite (smoothstep is GLSL-only, not\n    // Blink).\n    float safe_threshold = max(hue_chroma_threshold, 0.0001f);\n    float chroma_weight = smooth_ramp(0.0f, safe_threshold, current_lch.y);\n\n    // Feature 2: Global hue shift weighted by chroma.\n    float total_hue_shift = hue_shift_deg * chroma_weight;\n\n    // Feature 2: Per-band hue shifts, each using a 60-degree half-width cosine\n    // window. Band centre angles are perceptually placed on the OKLCH hue\n    // wheel.\n    float half = 60.0f;\n    float orig_H = current_lch.z;\n\n    total_hue_shift +=\n        hue_shift_red * hue_band_weight(orig_H, 0.0f, half) * chroma_weight;\n    total_hue_shift +=\n        hue_shift_yellow * hue_band_weight(orig_H, 85.0f, half) * chroma_weight;\n    total_hue_shift +=\n        hue_shift_green * hue_band_weight(orig_H, 145.0f, half) * chroma_weight;\n    total_hue_shift +=\n        hue_shift_cyan * hue_band_weight(orig_H, 195.0f, half) * chroma_weight;\n    total_hue_shift +=\n        hue_shift_blue * hue_band_weight(orig_H, 265.0f, half) * chroma_weight;\n    total_hue_shift += hue_shift_magenta *\n                       hue_band_weight(orig_H, 325.0f, half) * chroma_weight;\n\n    // Red band wraps around 360/0 — add a second lobe at 360 to catch hues near\n    // 360\n    total_hue_shift +=\n        hue_shift_red * hue_band_weight(orig_H, 360.0f, half) * chroma_weight;\n\n    // Optional precise hue correction around a user-picked target hue.\n    float safe_target_falloff = max(hue_target_falloff_deg, 0.1f);\n    float target_weight =\n        hue_band_weight(orig_H, wrap_hue_deg(hue_target_deg), safe_target_falloff) *\n        chroma_weight;\n    total_hue_shift += hue_target_shift * target_weight;\n\n    // --- Hue Curves: per-hue hue offset ---\n    if (hue_curves_enable && hue_lut_connected && hue_lut_width > 1) \{\n      float3 lut = sample_hue_lut(orig_H);\n      float curve_hue_shift = (lut.x - 0.5f) * 360.0f; // Red channel\n      total_hue_shift += curve_hue_shift * chroma_weight;\n    \}\n\n    float graded_H = wrap_hue_deg(orig_H + total_hue_shift);\n\n    // --- Debug modes ---\n    if (debug_mode == 1) \{ // Lightness\n      dst() = float4(graded_L, graded_L, graded_L, src_pixel.w);\n      return;\n    \}\n    if (debug_mode == 2) \{ // Chroma\n      dst() = float4(graded_C, graded_C, graded_C, src_pixel.w);\n      return;\n    \}\n    if (debug_mode == 3) \{ // Hue\n      float h_vis = graded_H / 360.0f;\n      dst() = float4(h_vis, h_vis, h_vis, src_pixel.w);\n      return;\n    \}\n    if (debug_mode ==\n        4) \{ // Chroma weight (visualise the achromatic falloff region)\n      dst() = float4(chroma_weight, chroma_weight, chroma_weight, src_pixel.w);\n      return;\n    \}\n    if (debug_mode == 5) \{ // Hue Curves LUT values\n      if (hue_curves_enable && hue_lut_connected && hue_lut_width > 1) \{\n        float3 lut = sample_hue_lut(orig_H);\n        dst() = float4(lut.x, lut.y, lut.z, src_pixel.w);\n      \} else \{\n        dst() = float4(0.5f, 0.5f, 0.5f, src_pixel.w);\n      \}\n      return;\n    \}\n\n    // --- Reconstruct and blend ---\n    float3 out_lab = oklch_to_oklab(float3(graded_L, graded_C, graded_H));\n    float3 out_xyz = oklab_to_xyz(out_lab);\n    float3 graded_rgb = xyz_to_linear_srgb(out_xyz);\n\n    if (clamp_output) \{\n      graded_rgb.x = clamp01(graded_rgb.x);\n      graded_rgb.y = clamp01(graded_rgb.y);\n      graded_rgb.z = clamp01(graded_rgb.z);\n    \}\n\n    float t = clamp(mix, 0.0f, 1.0f);\n    float3 final_rgb = in_rgb + ((graded_rgb - in_rgb) * t);\n\n    dst() = float4(final_rgb.x, final_rgb.y, final_rgb.z, src_pixel.w);\n  \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript_OKLCHGrade
  xpos -100
  ypos -151
 }
 OCIOColorSpace {
  in_colorspace scene_linear
  out_colorspace scene_linear
  name OCIOColorSpace_OUT
  xpos -100
  ypos -90
 }
 Output {
  name Output1
  xpos -100
  ypos -30
 }
end_group
